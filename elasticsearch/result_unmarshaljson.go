// Code generated by easyjson for marshaling/unmarshaling using:
// go get github.com/mailru/easyjson && go install github.com/mailru/easyjson/...@latest
// easyjson -all elasticsearch/result.go
// then edited to make non-pointers pointers, and split out custom Marshal code
// to another file.

package elasticsearch

import (
	json "encoding/json"

	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

type HitsCallBack func(*Hit)

// FromJSON is like UnmarshalJSON, but instead of storing all hits on the
// Result which might need too much memory, it passes each Hit to the given
// callback and only updates the Total count, but leaves Hits empty. Returns
// the number of Hits passed to the callback.
func (v *Result) FromJSON(data []byte, cb HitsCallBack) (int, error) {
	r := jlexer.Lexer{Data: data}
	n := easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch(&r, v, cb)
	return n, r.Error()
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Result) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch(&r, v, nil)
	return r.Error()
}

func easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch(in *jlexer.Lexer, out *Result, cb HitsCallBack) int {
	var n int

	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return 0
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "_scroll_id":
			out.ScrollID = string(in.String())
		case "took":
			out.Took = int(in.Int())
		case "timed_out":
			out.TimedOut = bool(in.Bool())
		case "hits":
			if in.IsNull() {
				in.Skip()
				out.HitSet = nil
			} else {
				if out.HitSet == nil {
					out.HitSet = new(HitSet)
				}
				n = (*out.HitSet).FromJSON(in, cb)
			}
		case "aggregations":
			if in.IsNull() {
				in.Skip()
				out.Aggregations = nil
			} else {
				if out.Aggregations == nil {
					out.Aggregations = new(Aggregations)
				}
				(*out.Aggregations).UnmarshalEasyJSON(in)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}

	return n
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Result) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch(l, v, nil)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *HitSetTotal) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch1(&r, v)
	return r.Error()
}

func easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch1(in *jlexer.Lexer, out *HitSetTotal) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "value":
			out.Value = int(in.Int())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *HitSetTotal) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch1(l, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *HitSet) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch2(&r, v, nil)
	return r.Error()
}

func easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch2(in *jlexer.Lexer, out *HitSet, cb HitsCallBack) int {
	var n int

	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return 0
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "total":
			(out.Total).UnmarshalEasyJSON(in)
		case "hits":
			if in.IsNull() {
				in.Skip()
				out.Hits = nil
			} else {
				in.Delim('[')
				if out.Hits == nil {
					if !in.IsDelim(']') {
						out.Hits = make([]Hit, 0, 2)
					} else {
						out.Hits = []Hit{}
					}
				} else {
					out.Hits = (out.Hits)[:0]
				}
				for !in.IsDelim(']') {
					var v1 Hit
					(v1).UnmarshalEasyJSON(in)

					if cb == nil {
						out.Hits = append(out.Hits, v1)
					} else {
						cb(&v1)
					}

					n++
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}

	return n
}

// FromJSON is like UnmarshalJSON, but instead of storing all hits on the
// Result which might need too much memory, it passes each Hit to the given
// callback and only updates the Total count, but leaves Hits empty.
func (v *HitSet) FromJSON(l *jlexer.Lexer, cb HitsCallBack) int {
	return easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch2(l, v, cb)
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *HitSet) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch2(l, v, nil)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Hit) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch3(&r, v)
	return r.Error()
}

func easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch3(in *jlexer.Lexer, out *Hit) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "_id":
			out.ID = string(in.String())
		case "_source":
			if in.IsNull() {
				in.Skip()
				out.Details = nil
			} else {
				if out.Details == nil {
					out.Details = new(Details)
				}
				(*out.Details).UnmarshalEasyJSON(in)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Hit) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch3(l, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Details) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch5(&r, v)
	return r.Error()
}

func easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch5(in *jlexer.Lexer, out *Details) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "_id":
			out.ID = string(in.String())
		case "ACCOUNTING_NAME":
			out.AccountingName = string(in.String())
		case "AVAIL_CPU_TIME_SEC":
			out.AvailCPUTimeSec = int64(in.Int64())
		case "BOM":
			out.BOM = string(in.String())
		case "Command":
			out.Command = string(in.String())
		case "JOB_NAME":
			out.JobName = string(in.String())
		case "Job":
			out.Job = string(in.String())
		case "MEM_REQUESTED_MB":
			out.MemRequestedMB = int64(in.Int64())
		case "MEM_REQUESTED_MB_SEC":
			out.MemRequestedMBSec = int64(in.Int64())
		case "NUM_EXEC_PROCS":
			out.NumExecProcs = int64(in.Int64())
		case "PENDING_TIME_SEC":
			out.PendingTimeSec = int64(in.Int64())
		case "QUEUE_NAME":
			out.QueueName = string(in.String())
		case "RUN_TIME_SEC":
			out.RunTimeSec = int64(in.Int64())
		case "timestamp":
			out.Timestamp = int64(in.Int64())
		case "USER_NAME":
			out.UserName = string(in.String())
		case "WASTED_CPU_SECONDS":
			out.WastedCPUSeconds = float64(in.Float64())
		case "WASTED_MB_SECONDS":
			out.WastedMBSeconds = float64(in.Float64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Details) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch5(l, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Buckets) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch6(&r, v)
	return r.Error()
}

func easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch6(in *jlexer.Lexer, out *Buckets) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "buckets":
			if in.IsNull() {
				in.Skip()
				out.Buckets = nil
			} else {
				in.Delim('[')
				if out.Buckets == nil {
					if !in.IsDelim(']') {
						out.Buckets = make([]interface{}, 0, 4)
					} else {
						out.Buckets = []interface{}{}
					}
				} else {
					out.Buckets = (out.Buckets)[:0]
				}
				for !in.IsDelim(']') {
					var v4 interface{}
					if m, ok := v4.(easyjson.Unmarshaler); ok {
						m.UnmarshalEasyJSON(in)
					} else if m, ok := v4.(json.Unmarshaler); ok {
						_ = m.UnmarshalJSON(in.Raw())
					} else {
						v4 = in.Interface()
					}
					out.Buckets = append(out.Buckets, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Buckets) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch6(l, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Aggregations) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch7(&r, v)
	return r.Error()
}

func easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch7(in *jlexer.Lexer, out *Aggregations) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "stats":
			if in.IsNull() {
				in.Skip()
				out.Stats = nil
			} else {
				if out.Stats == nil {
					out.Stats = new(Buckets)
				}
				(*out.Stats).UnmarshalEasyJSON(in)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Aggregations) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonD3b49167DecodeGithubComWtsiHgiGoFarmerElasticsearch7(l, v)
}
